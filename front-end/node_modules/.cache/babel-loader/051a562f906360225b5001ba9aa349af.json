{"ast":null,"code":"import _toConsumableArray from \"/home/sam/Documents/flipic/front-end/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nvar updateQueue = makeQueue();\n\nvar raf = function raf(fn) {\n  return schedule(fn, updateQueue);\n};\n\nvar writeQueue = makeQueue();\n\nraf.write = function (fn) {\n  return schedule(fn, writeQueue);\n};\n\nvar onStartQueue = makeQueue();\n\nraf.onStart = function (fn) {\n  return schedule(fn, onStartQueue);\n};\n\nvar onFrameQueue = makeQueue();\n\nraf.onFrame = function (fn) {\n  return schedule(fn, onFrameQueue);\n};\n\nvar onFinishQueue = makeQueue();\n\nraf.onFinish = function (fn) {\n  return schedule(fn, onFinishQueue);\n};\n\nvar timeouts = [];\n\nraf.setTimeout = function (handler, ms) {\n  var time = raf.now() + ms;\n\n  var cancel = function cancel() {\n    var i = timeouts.findIndex(function (t) {\n      return t.cancel == cancel;\n    });\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  var timeout = {\n    time: time,\n    handler: handler,\n    cancel: cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nvar findTimeout = function findTimeout(time) {\n  return ~(~timeouts.findIndex(function (t) {\n    return t.time > time;\n  }) || ~timeouts.length);\n};\n\nraf.cancel = function (fn) {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = function (fn) {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = function (fn) {\n  var lastArgs;\n\n  function queuedFn() {\n    try {\n      fn.apply(void 0, _toConsumableArray(lastArgs));\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = function () {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nvar nativeRaf = typeof window != 'undefined' ? window.requestAnimationFrame : function () {};\n\nraf.use = function (impl) {\n  return nativeRaf = impl;\n};\n\nraf.now = typeof performance != 'undefined' ? function () {\n  return performance.now();\n} : Date.now;\n\nraf.batchedUpdates = function (fn) {\n  return fn();\n};\n\nraf.catch = console.error;\nraf.frameLoop = 'always';\n\nraf.advance = function () {\n  if (raf.frameLoop !== 'demand') {\n    console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand');\n  } else {\n    update();\n  }\n};\n\nvar ts = -1;\nvar sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n\n    if (raf.frameLoop !== 'demand') {\n      nativeRaf(loop);\n    }\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  var prevTs = ts;\n  ts = raf.now();\n  var count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), function (t) {\n      return t.handler();\n    });\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  var next = new Set();\n  var current = next;\n  return {\n    add: function add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete: function _delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush: function flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, function (fn) {\n          return fn(arg) && next.add(fn);\n        });\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(function (value) {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nvar __raf = {\n  count: 0,\n  clear: function clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n};\nexport { __raf, raf };","map":{"version":3,"sources":["/home/sam/Documents/flipic/front-end/node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js"],"names":["updateQueue","makeQueue","raf","fn","schedule","writeQueue","write","onStartQueue","onStart","onFrameQueue","onFrame","onFinishQueue","onFinish","timeouts","setTimeout","handler","ms","time","now","cancel","i","findIndex","t","splice","__raf","count","timeout","findTimeout","start","length","delete","sync","batchedUpdates","throttle","lastArgs","queuedFn","throttled","args","nativeRaf","window","requestAnimationFrame","use","impl","performance","Date","catch","console","error","frameLoop","advance","warn","update","ts","queue","add","loop","prevTs","eachSafely","flush","Math","min","next","Set","current","has","arg","size","values","each","forEach","value","e","clear"],"mappings":"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","sourcesContent":["let updateQueue = makeQueue();\nconst raf = fn => schedule(fn, updateQueue);\nlet writeQueue = makeQueue();\n\nraf.write = fn => schedule(fn, writeQueue);\n\nlet onStartQueue = makeQueue();\n\nraf.onStart = fn => schedule(fn, onStartQueue);\n\nlet onFrameQueue = makeQueue();\n\nraf.onFrame = fn => schedule(fn, onFrameQueue);\n\nlet onFinishQueue = makeQueue();\n\nraf.onFinish = fn => schedule(fn, onFinishQueue);\n\nlet timeouts = [];\n\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\n\nraf.cancel = fn => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = fn => {\n  let lastArgs;\n\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nlet nativeRaf = typeof window != 'undefined' ? window.requestAnimationFrame : () => {};\n\nraf.use = impl => nativeRaf = impl;\n\nraf.now = typeof performance != 'undefined' ? () => performance.now() : Date.now;\n\nraf.batchedUpdates = fn => fn();\n\nraf.catch = console.error;\nraf.frameLoop = 'always';\n\nraf.advance = () => {\n  if (raf.frameLoop !== 'demand') {\n    console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand');\n  } else {\n    update();\n  }\n};\n\nlet ts = -1;\nlet sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n\n    if (raf.frameLoop !== 'demand') {\n      nativeRaf(loop);\n    }\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nconst __raf = {\n  count: 0,\n\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n\n};\n\nexport { __raf, raf };\n"]},"metadata":{},"sourceType":"module"}