{"version":3,"file":"reactusegesture.cjs.production.min.js","sources":["../src/utils/math.ts","../src/utils/rubberband.ts","../src/utils/utils.ts","../src/utils/resolveOptionsWith.ts","../src/utils/event.ts","../src/utils/config.ts","../src/hooks/buildConfig.ts","../src/utils/state.ts","../src/recognizers/Recognizer.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/utils/memoize-one.ts","../src/utils/react-fast-compare.ts","../src/recognizers/PinchRecognizer.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/WheelRecognizer.ts","../src/recognizers/MoveRecognizer.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useGesture.ts","../src/hooks/useDrag.ts","../src/hooks/useHover.ts","../src/hooks/useMove.ts","../src/hooks/usePinch.ts","../src/hooks/useScroll.ts","../src/hooks/useWheel.ts"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && 'ontouchstart' in window\n}\n\nexport function supportsPointerEvents(): boolean {\n  return typeof window !== 'undefined' && 'onpointerdown' in window\n}\n\nfunction getEventTouches(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent) {\n  if ('pointerId' in event) return null\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches\n}\n\nexport function getTouchIds(event: TouchEvent | React.TouchEvent): number[] {\n  return Array.from(getEventTouches(event)!).map(t => t.identifier)\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent,\n  transform = identity\n): Vector2 {\n  const touchEvents = getEventTouches(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return transform([clientX, clientY])\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventValues(\n  event: React.TouchEvent | TouchEvent,\n  pointerIds: [number, number],\n  transform = identity\n) {\n  const [A, B] = Array.from(event.touches).filter(t => pointerIds.includes(t.identifier))\n\n  if (!A || !B) throw Error(`The event doesn't have two pointers matching the pointerIds`)\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\n  const values: Vector2 = transform([distance, angle])\n  const origin: Vector2 = transform([cx, cy])\n\n  return { values, origin }\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent, transform = identity): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0])\n}\n\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\nconst LINE_HEIGHT = 40\nconst PAGE_HEIGHT = 800\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent, transform = identity): Vector2 {\n  let { deltaX, deltaY, deltaMode } = event\n  // normalize wheel values, especially for Firefox\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT\n    deltaY *= LINE_HEIGHT\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT\n    deltaY *= PAGE_HEIGHT\n  }\n  return transform([deltaX, deltaY])\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent, transform = identity): Vector2 {\n  return transform([event.scale, event.rotation])\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\nimport { supportsTouchEvents, supportsPointerEvents } from './event'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 50\nexport const DEFAULT_SWIPE_DURATION = 250\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n\n  transform: true,\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n  transform: true,\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  useTouch(value = false) {\n    const supportsTouch = supportsTouchEvents()\n    const supportsPointer = supportsPointerEvents()\n    if (value && supportsTouch) return true\n    if (supportsTouch && !supportsPointer) return true\n    return false\n  },\n  experimental_preventWindowScrollY(value = false) {\n    return value\n  },\n  threshold(\n    this: InternalDragOptions,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n  swipeDuration(value = DEFAULT_SWIPE_DURATION) {\n    return value\n  },\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, transform, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({\n    domTarget,\n    eventOptions,\n    transform,\n    window,\n    enabled,\n  })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState, PinchState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _threshold: [0, 0],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle & PinchState>({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {\n    this.controller = controller\n    this.args = args\n  }\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  get transform() {\n    return this.config.transform || this.controller.config.transform || identity\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { rubberband } = this.config\n\n    const {\n      _bounds,\n      _initial,\n      _active,\n      _intentional: wasIntentional,\n      lastOffset,\n      movement: prevMovement,\n      _threshold: _T,\n    } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : 0,\n      _intentional[1] !== false ? M[1] - _intentional[1] : 0,\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const touches = this.controller.pointerIds.size || this.controller.touchIds.size\n    const down = this.controller.state.shared.buttons > 0 || touches > 0\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n      locked: !!document.pointerLockElement,\n      touches,\n      down,\n    } as FullGestureState<T>\n\n    // @ts-expect-error\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  { state, config, stateKey, args, transform }: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T],\n  initial?: Vector2\n) {\n  const offset = state.offset\n  const startTime = event.timeStamp\n\n  const { initial: initialFn, bounds, threshold } = config\n\n  // the _threshold is the difference between a [0,0] offset converted to\n  // its new space coordinates\n  const _threshold = subV(transform(threshold), transform([0, 0])).map(Math.abs)\n\n  const _state = {\n    ...getInitialState()[stateKey],\n    _active: true,\n    args,\n    values,\n    initial: initial ?? values,\n    _threshold,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n\n  return { ..._state, _initial: valueFn(initialFn, _state), _bounds: valueFn(bounds, _state) }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { supportsTouchEvents, supportsGestureEvents, getTouchIds } from './utils/event'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  public pointerIds = new Set<number>() // register Pointer Events pointerIds\n  public touchIds = new Set<number>() // register Touch Events identifiers\n  public supportsTouchEvents = supportsTouchEvents()\n  public supportsGestureEvents = supportsGestureEvents()\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.classes = classes\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // // we also add event bindings for native handlers\n    for (let eventKey in this.nativeRefs) {\n      addBindings(bindings, eventKey, (event: any) => this.nativeRefs[eventKey]({ ...this.state.shared, event, args }))\n    }\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function addEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.add(event.pointerId)\n  } else {\n    controller.touchIds = new Set(getTouchIds(event))\n  }\n}\n\nexport function removeEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.delete(event.pointerId)\n  } else {\n    getTouchIds(event).forEach(id => controller.touchIds.delete(id))\n  }\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = [],\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), options)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into account)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners, addEventIds, removeEventIds } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nfunction persistEvent(event: React.PointerEvent | PointerEvent) {\n  'persist' in event && typeof event.persist === 'function' && event.persist()\n}\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  // TODO add back when setPointerCapture is widely wupported\n  // https://caniuse.com/#search=setPointerCapture\n  private setPointerCapture = (event: React.PointerEvent | PointerEvent) => {\n    // don't perform pointere capture when user wants to use touch events or\n    // when a pointerLockElement exists as this would throw an error\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { target, pointerId } = event\n    if (target && 'setPointerCapture' in target) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      // @ts-expect-error\n      target.setPointerCapture(pointerId)\n    }\n    this.updateGestureState({ _dragTarget: target, _dragPointerId: pointerId })\n  }\n\n  private releasePointerCapture = () => {\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { _dragTarget, _dragPointerId } = this.state\n    if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))\n        try {\n          _dragTarget.releasePointerCapture(_dragPointerId)\n        } catch (e) {}\n    }\n  }\n\n  private preventScroll = (event: TouchEvent) => {\n    if (this.state._dragPreventScroll && event.cancelable) {\n      event.preventDefault()\n    }\n  }\n\n  private getEventId = (event: any): number => {\n    if (this.config.useTouch) return event.changedTouches[0].identifier\n    return event.pointerId\n  }\n\n  private isValidEvent = (event: any) => {\n    // if we were using pointer events only event.isPrimary === 1 would suffice\n    return this.state._pointerId === this.getEventId(event)\n  }\n\n  private shouldPreventWindowScrollY =\n    this.config.experimental_preventWindowScrollY && this.controller.supportsTouchEvents\n\n  private setUpWindowScrollDetection = (event: React.PointerEvent | PointerEvent) => {\n    persistEvent(event)\n    // we add window listeners that will prevent the scroll when the user has started dragging\n    updateWindowListeners(\n      this.controller,\n      this.stateKey,\n      [\n        ['touchmove', this.preventScroll],\n        ['touchend', this.clean.bind(this)],\n        ['touchcancel', this.clean.bind(this)],\n      ],\n      { passive: false }\n    )\n    this.setTimeout(this.startDrag.bind(this), 250, event)\n  }\n\n  private setUpDelayedDragTrigger = (event: React.PointerEvent | PointerEvent) => {\n    this.state._dragDelayed = true\n    persistEvent(event)\n    this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n  }\n\n  private setStartState = (event: React.PointerEvent | PointerEvent) => {\n    const values = getPointerEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: this.getEventId(event), // setting pointerId locks the gesture to this specific event\n    })\n\n    this.updateGestureState(this.getMovement(values))\n  }\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    addEventIds(this.controller, event)\n    if (!this.enabled || this.state._active) return\n\n    this.setStartState(event)\n    this.setPointerCapture(event as PointerEvent)\n\n    if (this.shouldPreventWindowScrollY) this.setUpWindowScrollDetection(event)\n    else if (this.config.delay > 0) this.setUpDelayedDragTrigger(event)\n    else this.startDrag(event, true) // we pass the values to the startDrag event\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent, onDragIsStart: boolean = false) {\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n    if (\n      // if the gesture isn't active (probably means)\n      !this.state._active ||\n      // if the drag has already started we should ignore subsequent attempts\n      this.state._dragStarted\n    )\n      return\n\n    if (!onDragIsStart) this.setStartState(event)\n    this.updateGestureState({ _dragStarted: true, _dragPreventScroll: true, cancel: this.onCancel })\n    this.clearTimeout()\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    if (\n      // if the gesture was canceled or\n      this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !this.isValidEvent(event) ||\n      // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests ¯\\_(ツ)_/¯\n      (this.state._lastEventType === event.type && event.timeStamp === this.state.timeStamp)\n    )\n      return\n\n    let values\n\n    if (document.pointerLockElement) {\n      const { movementX, movementY } = event\n      values = addV(this.transform([movementX, movementY]), this.state.values)\n    } else values = getPointerEventValues(event, this.transform)\n\n    const kinematics = this.getKinematics(values, event)\n\n    // if startDrag hasn't fired\n    if (!this.state._dragStarted) {\n      // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n      if (this.state._dragDelayed) {\n        this.startDrag(event)\n        return\n      }\n      // if the user wants to prevent vertical window scroll when user starts dragging\n      if (this.shouldPreventWindowScrollY) {\n        if (!this.state._dragPreventScroll && kinematics.axis) {\n          // if the user is dragging horizontally then we should allow the drag\n          if (kinematics.axis === 'x') {\n            this.startDrag(event)\n          } else {\n            this.state._active = false\n            return\n          }\n        } else return\n      } else return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    const realDistance = calculateDistance(kinematics._movement!)\n    let { _dragIsTap } = this.state\n    if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _dragIsTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    removeEventIds(this.controller, event)\n\n    // if the event pointerId doesn't match the one that initiated the drag\n    // we don't want to end the drag\n    if (!this.isValidEvent(event)) return\n    this.clean()\n\n    // if the gesture is no longer active (ie canceled)\n    // don't do anything\n    if (!this.state._active) return\n    this.state._active = false\n\n    const tap = this.state._dragIsTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n    const sd = this.config.swipeDuration\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < sd) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateSharedState({ buttons: 0 })\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(this.config.filterTaps && tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._dragStarted = false\n    this.releasePointerCapture()\n    clearWindowListeners(this.controller, this.stateKey)\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true, _active: false })\n    this.updateSharedState({ buttons: 0 })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._dragIsTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart)\n      addBindings(bindings, 'onTouchMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd)\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd)\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart)\n      addBindings(bindings, 'onPointerMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onPointerUp', this.onDragEnd)\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    }\n\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n  }\n}\n","/**\n * Inlined from https://github.com/alexreardon/memoize-one\n */\n\nexport type EqualityFn = (newArgs: any[], lastArgs: any[]) => boolean\n\nexport default function memoizeOne<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(\n  resultFn: ResultFn,\n  isEqual: EqualityFn\n): ResultFn {\n  let lastThis: unknown\n  let lastArgs: unknown[] = []\n  let lastResult: ReturnType<ResultFn>\n  let calledOnce: boolean = false\n\n  function memoized(this: unknown, ...newArgs: unknown[]): ReturnType<ResultFn> {\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult\n    }\n\n    lastResult = resultFn.apply(this, newArgs)\n    calledOnce = true\n    lastThis = this\n    lastArgs = newArgs\n    return lastResult\n  }\n\n  return memoized as ResultFn\n}\n","/**\n * Taken from https://github.com/FormidableLabs/react-fast-compare\n *\n * Dropped comments and ArrayBuffer handling\n */\n\nfunction equal(a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    let it\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false\n      return true\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      return true\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf()\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false\n\n    for (i = length; i-- !== 0; ) {\n      if (keys[i] === '_owner' && a.$$typeof) continue\n      if (!equal(a[keys[i]], b[keys[i]])) return false\n    }\n    return true\n  }\n\n  // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport default function isEqual(a: any, b: any) {\n  try {\n    return equal(a, b)\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      // eslint-disable-next-line no-console\n      console.warn('react-fast-compare cannot handle circular refs')\n      return false\n    }\n    throw error\n  }\n}\n","import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventValues,\n  getWheelEventValues,\n  getWebkitGestureEventValues,\n  getTouchIds,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, addEventIds, removeEventIds } from '../Controller'\n\nconst ZOOM_CONSTANT = 7\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  onPinchStart = (event: React.TouchEvent | TouchEvent) => {\n    addEventIds(this.controller, event)\n    const touchIds = this.controller.touchIds\n\n    if (!this.enabled) return\n\n    if (this.state._active) {\n      // check that the pointerIds that initiated the gesture\n      // are still enabled. This is useful for when the page\n      // loses track of the pointers (minifying gesture on iPad).\n      if (this.state._pointerIds.every(id => touchIds.has(id))) return\n      // something was wrong with the pointers but we let it go.\n    }\n    // until we reach two fingers on the target don't react\n    if (touchIds.size < 2) return\n    const _pointerIds = Array.from(touchIds).slice(0, 2) as [number, number]\n\n    const { values, origin } = getTwoTouchesEventValues(event, _pointerIds, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerIds,\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: React.TouchEvent | TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (\n      canceled ||\n      !_active ||\n      // if the event has the same timestamp as the previous event\n      event.timeStamp === this.state.timeStamp\n    )\n      return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    try {\n      const { values, origin } = getTwoTouchesEventValues(event, this.state._pointerIds, this.transform)\n      const kinematics = this.getKinematics(values, event)\n\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...kinematics,\n        origin,\n      })\n\n      this.fireGestureHandler()\n    } catch (e) {\n      this.onPinchEnd(event)\n    }\n  }\n\n  onPinchEnd = (event: React.TouchEvent | TouchEvent): void => {\n    removeEventIds(this.controller, event)\n    const pointerIds = getTouchIds(event)\n\n    // if none of the lifted pointerIds is in the state pointerIds don't do anything\n    if (this.state._pointerIds.every(id => !pointerIds.includes(id))) return\n\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ _active: false, canceled: true })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const values = getWebkitGestureEventValues(event, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    // this normalizes the values of the Safari's WebKitEvent by calculating\n    // the delta and then multiplying it by a constant.\n    const values = getWebkitGestureEventValues(event, this.transform)\n    values[0] =\n      (values[0] - (this.state.event as WebKitGestureEvent).scale) * WEBKIT_DISTANCE_SCALE_FACTOR + this.state.values[0]\n\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: React.WheelEvent | WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: React.WheelEvent | WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event, this.transform)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    // ZOOM_CONSTANT is based on Safari trackpad natural zooming\n    const _delta_d = -delta_d * ZOOM_CONSTANT\n    // new distance is the previous state distance added to the delta\n    const d = prev_d + _delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [_delta_d, a] as Vector2,\n    }\n  }\n\n  onWheel = (event: React.WheelEvent | WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: React.WheelEvent | WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event, this.state.values),\n      ...getGenericPayload(this, event, true),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.cancelable) event.preventDefault()\n\n    this.updateSharedState(getGenericEventData(event))\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (\n      this.controller.config.domTarget &&\n      !this.controller.supportsTouchEvents &&\n      this.controller.supportsGestureEvents\n    ) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart)\n      addBindings(bindings, 'onGestureChange', this.onGestureChange)\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart)\n      addBindings(bindings, 'onTouchMove', this.onPinchChange)\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd)\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd)\n      addBindings(bindings, 'onWheel', this.onWheel)\n    }\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state._movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const { distance, velocity, ...kinematics } = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event, this.transform), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  hoverTransform = () => {\n    return this.controller.config.hover!.transform || this.controller.config.transform\n  }\n\n  onPointerEnter = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event, this.hoverTransform())\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        args: this.args,\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event, this.hoverTransform())\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      args: this.args,\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: React.UIEvent | UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.updateGestureState({ ...this.getMovement(this.state.values), _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n","import { UseDragConfig, Handler, EventTypes } from '../types'\nimport { _buildDragConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Drag hook.\n *\n * @param handler - the function fired every time the drag gesture updates\n * @param [config={}] - the config object including generic options and drag options\n */\nexport function useDrag<K = EventTypes['drag']>(handler: Handler<'drag', K>, config: UseDragConfig | {} = {}) {\n  RecognizersMap.set('drag', DragRecognizer)\n  const buildDragConfig = useRef<any>()\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoize(_buildDragConfig, isEqual)\n  }\n  return useRecognizers<UseDragConfig>({ drag: handler }, buildDragConfig.current(config))\n}\n","import { Handler, UseHoverConfig, EventTypes } from '../types'\nimport { _buildHoverConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Hover hook.\n *\n * @param handler - the function fired every time the hover gesture updates\n * @param [config={}] - the config object including generic options and hover options\n */\nexport function useHover<K = EventTypes['hover']>(handler: Handler<'hover', K>, config: UseHoverConfig | {} = {}) {\n  RecognizersMap.set('hover', MoveRecognizer)\n  const buildHoverConfig = useRef<any>()\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoize(_buildHoverConfig, isEqual)\n  }\n  return useRecognizers<UseHoverConfig>({ hover: handler }, buildHoverConfig.current(config))\n}\n","import { UseMoveConfig, Handler, EventTypes } from '../types'\nimport { _buildMoveConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Move hook.\n *\n * @param handler - the function fired every time the move gesture updates\n * @param [config={}] - the config object including generic options and move options\n */\nexport function useMove<K = EventTypes['move']>(handler: Handler<'move', K>, config: UseMoveConfig | {} = {}) {\n  RecognizersMap.set('move', MoveRecognizer)\n  const buildMoveConfig = useRef<any>()\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoize(_buildMoveConfig, isEqual)\n  }\n  return useRecognizers<UseMoveConfig>({ move: handler }, buildMoveConfig.current(config))\n}\n","import { UsePinchConfig, Handler, EventTypes } from '../types'\nimport { _buildPinchConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Pinch hook.\n *\n * @param handler - the function fired every time the pinch gesture updates\n * @param [config={}] - the config object including generic options and pinch options\n */\nexport function usePinch<K = EventTypes['pinch']>(handler: Handler<'pinch', K>, config: UsePinchConfig | {} = {}) {\n  RecognizersMap.set('pinch', PinchRecognizer)\n  const buildPinchConfig = useRef<any>()\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoize(_buildPinchConfig, isEqual)\n  }\n  return useRecognizers<UsePinchConfig>({ pinch: handler }, buildPinchConfig.current(config))\n}\n","import { UseScrollConfig, Handler, EventTypes } from '../types'\nimport { _buildScrollConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Scroll hook.\n *\n * @param handler - the function fired every time the scroll gesture updates\n * @param [config={}] - the config object including generic options and scroll options\n */\nexport function useScroll<K = EventTypes['scroll']>(handler: Handler<'scroll', K>, config: UseScrollConfig | {} = {}) {\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  const buildScrollConfig = useRef<any>()\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoize(_buildScrollConfig, isEqual)\n  }\n  return useRecognizers<UseScrollConfig>({ scroll: handler }, buildScrollConfig.current(config))\n}\n","import { UseWheelConfig, Handler, EventTypes } from '../types'\nimport { _buildWheelConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Wheel hook.\n *\n * @param handler - the function fired every time the wheel gesture updates\n * @param the config object including generic options and wheel options\n */\nexport function useWheel<K = EventTypes['wheel']>(handler: Handler<'wheel', K>, config: UseWheelConfig | {} = {}) {\n  RecognizersMap.set('wheel', WheelRecognizer)\n  const buildWheelConfig = useRef<any>()\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoize(_buildWheelConfig, isEqual)\n  }\n  return useRecognizers<UseWheelConfig>({ wheel: handler }, buildWheelConfig.current(config))\n}\n"],"names":["addV","v1","v2","map","v","i","subV","calculateDistance","movement","Math","hypot","calculateAllGeometry","delta","dl","alpha","direction","distance","calculateAllKinematics","dt","beta","velocity","velocities","sign","x","Number","rubberband","dimension","constant","Infinity","abs","pow","rubberband2","rubberbandIfOutOfBounds","position","min","max","value","minMax","noop","chainFns","fns","length","result","fn","apply","this","arguments","ensureVector","fallback","undefined","Error","Array","isArray","assignDefault","Object","assign","valueFn","args","resolveWith","config","resolvers","entries","key","resolver","call","supportsTouchEvents","window","getEventTouches","event","type","changedTouches","targetTouches","getTouchIds","from","t","identifier","getGenericEventData","buttons","shiftKey","altKey","metaKey","ctrlKey","identity","xy","getPointerEventValues","transform","touchEvents","clientX","clientY","getTwoTouchesEventValues","pointerIds","touches","filter","includes","A","B","dx","dy","cx","cy","values","atan2","PI","origin","getScrollEventValues","currentTarget","scrollX","scrollLeft","scrollY","scrollTop","getWheelEventValues","deltaX","deltaY","deltaMode","getWebkitGestureEventValues","scale","rotation","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","axis","lockDirection","bounds","state","left","right","top","bottom","isBrowser","document","createElement","InternalGenericOptionsNormalizers","domTarget","eventOptions","passive","capture","InternalDistanceAngleOptionsNormalizers","_value","_key","distanceBounds","angleBounds","_distanceBounds","D","_angleBounds","InternalDragOptionsNormalizers","useTouch","supportsTouch","supportsPointer","experimental_preventWindowScrollY","_k","filterTaps","swipeVelocity","swipeDistance","swipeDuration","delay","getInternalGenericOptions","getInternalCoordinatesOptions","getInternalDistanceAngleOptions","getInternalDragOptions","_buildMoveConfig","rest","opts","move","_buildHoverConfig","hover","_buildDragConfig","drag","_buildPinchConfig","pinch","_buildScrollConfig","scroll","_buildWheelConfig","wheel","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_threshold","_lastEventType","_dragStarted","_dragPreventScroll","_dragIsTap","_dragDelayed","intentional","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","down","locked","_pointerId","vxvy","tap","swipe","_pointerIds","da","vdva","turns","RecognizersMap","Map","Recognizer","controller","callback","ms","clearTimeout","_this","timeouts","stateKey","setTimeout","forceFlag","debounced","clean","prev_active","next_active","ingKey","size","touchIds","mapStateValues","pointerLockElement","newMemo","handler","updateSharedState","sharedState","updateGestureState","gestureState","checkIntentionality","getMovement","wasIntentional","prevMovement","_T","M","getInternalMovement","i0","getIntentionalDisplacement","i1","intentionalityCheck","_rubberband","computeRubberband","handlers","Vy","Ry","Y1","Y2","getGenericPayload","isStartEvent","getStartGestureState","initialFn","_state","Controller","classes","Set","GestureEvent","e","supportsGestureEvents","bindings","RecognizerClass","addBindings","eventKey","nativeRefs","updateDomListeners","getPropsListener","bind","getDomTargetFromConfig","removeListeners","takeAll","domListeners","forEach","el","windowListeners","clearAllWindowListeners","addEventIds","add","pointerId","removeEventIds","id","clearWindowListeners","options","updateWindowListeners","listeners","addListeners","name","slice","toLowerCase","push","props","captureString","fnsArray","array","splice","current","addEventListener","removeEventListener","useRecognizers","nativeHandlers","internalHandlers","get","resolveClasses","React","useMemo","useEffect","effect","deprecationNoticeForDomTarget","CoordinatesRecognizer","absX","absY","getKinematics","persistEvent","persist","DragRecognizer","target","setPointerCapture","_dragTarget","_dragPointerId","hasPointerCapture","releasePointerCapture","cancelable","preventDefault","getEventId","preventScroll","startDrag","setStartState","shouldPreventWindowScrollY","setUpWindowScrollDetection","setUpDelayedDragTrigger","isValidEvent","movementX","movementY","kinematics","genericEventData","genericPayload","realDistance","fireGestureHandler","vx","vy","mx","my","ix","iy","svx","svy","sx","sy","sd","endState","stopPropagation","onDragIsStart","onCancel","onDragStart","onDragChange","onDragEnd","onClick","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","a","b","equal","constructor","keys","it","next","done","has","RegExp","source","flags","valueOf","prototype","toString","hasOwnProperty","Element","$$typeof","error","message","match","console","warn","PinchRecognizer","every","onPinchEnd","prev_a","_delta_d","wheelShouldRun","onWheelEnd","onWheelChange","onWheelStart","getWheelValuesFromEvent","onGestureStart","onGestureChange","onGestureEnd","onPinchStart","onPinchChange","onWheel","d","delta_a","next_turns","WheelRecognizer","onEnd","geometry","handleEvent","MoveRecognizer","onMoveEnd","onMoveChange","onMoveStart","hoverTransform","onMove","onPointerEnter","onPointerLeave","ScrollRecognizer","movementDetection","RE_NOT_NATIVE","includeStartEndHandlers","handlerKey","startKey","endKey","set","buildDragConfig","useRef","memoize","_handlers","native","handle","actions","test","lastMatch","sortHandlers","mergedConfig","buildComplexConfig","onHover","buildHoverConfig","buildMoveConfig","buildPinchConfig","buildScrollConfig","buildWheelConfig"],"mappings":"6JACgBA,EAAyBC,EAAOC,UACvCD,EAAGE,KAAI,SAACC,EAAGC,UAAMD,EAAIF,EAAGG,eAIjBC,EAAyBL,EAAOC,UACvCD,EAAGE,KAAI,SAACC,EAAGC,UAAMD,EAAIF,EAAGG,eAQjBE,EAAkBC,UACzBC,KAAKC,YAALD,KAAcD,YAUPG,EAAyCH,EAAaI,YAAAA,IAAAA,EAAWJ,OACzEK,EAAKN,EAAkBK,GAEvBE,EAAe,IAAPD,EAAW,EAAI,EAAIA,EAE3BE,EAAYH,EAAMT,KAAI,SAAAC,UAAKU,EAAQV,WAGlC,CAAEY,SAFQT,EAAkBC,GAEhBO,UAAAA,YAWLE,EAA2CT,EAAaI,EAAUM,OAC1EL,EAAKN,EAAkBK,GAEvBE,EAAe,IAAPD,EAAW,EAAI,EAAIA,EAC3BM,EAAc,IAAPD,EAAW,EAAI,EAAIA,EAE1BE,EAAWD,EAAON,EAClBQ,EAAaT,EAAMT,KAAI,SAAAC,UAAKe,EAAOf,KACnCW,EAAYH,EAAMT,KAAI,SAAAC,UAAKU,EAAQV,WAGlC,CAAEiB,WAAAA,EAAYD,SAAAA,EAAUJ,SAFdT,EAAkBC,GAEMO,UAAAA,YAS3BO,EAAKC,UACfd,KAAKa,KAAab,KAAKa,KAAKC,GACzBC,OAAOD,EAAI,GAAKC,OAAOD,EAAI,KAAOA,ECrD3C,SAASE,EAAWT,EAAkBU,EAAmBC,UACrC,IAAdD,GAA2CE,WAAxBnB,KAAKoB,IAAIH,GANlC,SAAqBV,EAAkBW,UAE9BlB,KAAKqB,IAAId,EAAqB,EAAXW,GAIsCI,CAAYf,EAAUW,GAC9EX,EAAWU,EAAYC,GAAaD,EAAYC,EAAWX,GAGrE,SAAgBgB,EAAwBC,EAAkBC,EAAaC,EAAaR,mBAAAA,IAAAA,EAAW,KAC5E,IAAbA,EApBN,SAAgBS,EAAeF,EAAaC,UACnC1B,KAAK0B,IAAID,EAAKzB,KAAKyB,IAAIE,EAAOD,IAmBVE,CAAOJ,EAAUC,EAAKC,GAC7CF,EAAWC,GAAaT,EAAWS,EAAMD,EAAUE,EAAMD,EAAKP,GAAYO,EAC1ED,EAAWE,GAAaV,EAAWQ,EAAWE,EAAKA,EAAMD,EAAKP,GAAYQ,EACvEF,u3CCvBOK,KAQhB,SAAgBC,+BAAYC,2BAAAA,yBACP,IAAfA,EAAIC,OAAqBH,EACV,IAAfE,EAAIC,OAAqBD,EAAI,GAE1B,mBACDE,QACWF,kBAAK,KAAXG,UACPD,EAASC,EAAGC,MAAMC,KAAMC,YAAcJ,SAEjCA,YAWKK,EAAgBX,EAA+BY,WAC/CC,IAAVb,EAAqB,SACNa,IAAbD,QACI,IAAIE,MAAM,uDAElBd,EAAQY,SAGNG,MAAMC,QAAQhB,GAAeA,EAC1B,CAACA,EAAOA,YASDiB,EAAgCjB,EAA+BY,UACtEM,OAAOC,OAAO,GAAIP,EAAUZ,GAAS,aAS9BoB,EAAWpD,MACR,mBAANA,EAAkB,4BAD+BqD,mCAAAA,2BAGnDrD,eAAKqD,UAELrD,WC1DKsD,EACdC,EACAC,YADAD,IAAAA,EAAqB,YAGfjB,EAAc,SAEUY,OAAOO,QAAQD,8BAAjCE,OAAKC,qBACAA,OACR,WACHrB,EAAOoB,GAAOC,EAASC,KAAKtB,EAAQiB,EAAOG,GAAMA,EAAKH,aAEnD,SACHjB,EAAOoB,GAAOJ,EAAYC,EAAOG,GAAMC,aAEpC,UACCA,IAAUrB,EAAOoB,GAAOH,EAAOG,YAIlCpB,ECNT,SAAgBuB,UACW,oBAAXC,QAA0B,iBAAkBA,OAO5D,SAASC,EAAgBC,SACnB,cAAeA,EAAc,KACX,aAAfA,EAAMC,KAAsBD,EAAME,eAAiBF,EAAMG,uBAGlDC,EAAYJ,UACnBjB,MAAMsB,KAAKN,EAAgBC,IAASjE,KAAI,SAAAuE,UAAKA,EAAEC,uBAGxCC,EAAoBR,SAG3B,CAAES,QAFO,YAAaT,EAAQA,EAAMS,QAAU,EAEnCC,SAD6BV,EAAvCU,SACoBC,OADmBX,EAA7BW,OACkBC,QADWZ,EAArBY,QACmBC,QADEb,EAAZa,SAIrC,IAAMC,EAAW,SAACC,UAAgBA,YAOlBC,EACdhB,EACAiB,YAAAA,IAAAA,EAAYH,OAENI,EAAcnB,EAAgBC,KACPkB,EAAcA,EAAY,GAAMlB,SACtDiB,EAAU,GADTE,UAASC,UASnB,SAAgBC,EACdrB,EACAsB,EACAL,YAAAA,IAAAA,EAAYH,SAEG/B,MAAMsB,KAAKL,EAAMuB,SAASC,QAAO,SAAAlB,UAAKgB,EAAWG,SAASnB,EAAEC,eAApEmB,OAAGC,WAELD,IAAMC,EAAG,MAAM7C,yEAEd8C,EAAKD,EAAER,QAAUO,EAAEP,QACnBU,EAAKF,EAAEP,QAAUM,EAAEN,QACnBU,GAAMH,EAAER,QAAUO,EAAEP,SAAW,EAC/BY,GAAMJ,EAAEP,QAAUM,EAAEN,SAAW,QAW9B,CAAEY,OAHef,EAAU,CAJjB5E,KAAKC,MAAMsF,EAAIC,IAGK,IAArBxF,KAAK4F,MAAML,EAAIC,GAAaxF,KAAK6F,KAIhCC,OAFOlB,EAAU,CAACa,EAAIC,cAUzBK,EAAqBpC,EAAgCiB,YAAAA,IAAAA,EAAYH,SAG3Bd,EAAMqC,qBACnDpB,EAAU,GADTqB,WAAkBC,YACiB,IAD1BC,WAAqBC,WACgC,aAYxDC,EAAoB1C,EAAsCiB,YAAAA,IAAAA,EAAYH,OAC9E6B,EAA8B3C,EAA9B2C,OAAQC,EAAsB5C,EAAtB4C,OAAQC,EAAc7C,EAAd6C,iBAEJ,IAAdA,GACFF,GAZgB,GAahBC,GAbgB,IAcO,IAAdC,IACTF,GAdgB,IAehBC,GAfgB,KAiBX3B,EAAU,CAAC0B,EAAQC,aAQZE,EAA4B9C,EAA2BiB,mBAAAA,IAAAA,EAAYH,GAC1EG,EAAU,CAACjB,EAAM+C,MAAO/C,EAAMgD,WCvGhC,IAMDC,EAAoC,CACxCC,mBAAUlF,mBAAAA,IAAAA,EAA0B,GAC3BW,EAAaX,IAGtBX,oBAAWW,mBAAAA,IAAAA,EAAoC,GACrCA,QACD,SACIW,EAbmB,UAcvB,SACIA,EAAa,kBAEbA,EAAaX,KAI1BmF,iBAAQnF,mBAAAA,IAAAA,GAAQ,GACPA,GAGToF,0BAAiBpF,mBAAAA,IAAAA,GAAQ,GAChBA,GAGTqF,iBAAQrF,mBAAAA,IAAAA,EAAQ,GACO,mBAAVA,EAA6BA,EACjCW,EAAaX,IAGtBiD,WAAW,GAGPqC,OACDL,GACHM,MAAM,EACNC,uBAAcxF,mBAAAA,IAAAA,GAAQ,GACbA,GAETyF,gBAAOzF,eAAAA,IAAAA,EAA8C,IAC9B,mBAAVA,EACT,OAAO,SAAC0F,UAAkBJ,EAAsCG,OAAOzF,EAAM0F,WAEI1F,EAA3E2F,OAA2E3F,EAAzD4F,QAAyD5F,EAAvC6F,MAAuC7F,EAAtB8F,aAEtD,CACL,aAHctG,sBAAkBA,YAIhC,aAJiDA,sBAAmBA,gBASpEuG,EAA8B,oBAAXjE,QAA0BA,OAAOkE,UAAYlE,OAAOkE,SAASC,cAEhFC,EAAoC,CACxCf,iBAAQnF,mBAAAA,IAAAA,GAAQ,GACPA,GAETmG,WAAW,EACXrE,+HAAO9B,mBAAAA,IAAAA,EAAQ+F,EAAYjE,YAASjB,GAC3Bb,KAEToG,0CAAmD,SAApCC,YAAgBC,cACtB,CAAED,sBAASC,wBAEpBrD,WAAW,GAGPsD,OACDtB,GAEHQ,gBAAOe,EAAmBC,aAAgBC,eAAAA,aAAiB,SAAIC,YAAAA,aAAc,KACrEC,EAAkB,SAAClB,OACjBmB,EAAI5F,EAAcG,EAAQsF,EAAgBhB,GAAQ,CAAE5F,KAAMN,SAAUO,IAAKP,iBACxE,CAACqH,EAAE/G,IAAK+G,EAAE9G,MAGb+G,EAAe,SAACpB,OACdhC,EAAIzC,EAAcG,EAAQuF,EAAajB,GAAQ,CAAE5F,KAAMN,SAAUO,IAAKP,iBACrE,CAACkE,EAAE5D,IAAK4D,EAAE3D,YAGW,mBAAnB2G,GAAwD,mBAAhBC,EAC1C,CAACC,IAAmBE,KAEtB,SAACpB,SAAkB,CAACkB,EAAgBlB,GAAQoB,EAAapB,QAI9DqB,OACDzB,GAEH0B,kBAAShH,YAAAA,IAAAA,GAAQ,OACTiH,EAAgBpF,IAChBqF,EDrGiB,oBAAXpF,QAA0B,kBAAmBA,gBCsGrD9B,IAASiH,OACTA,GAAkBC,IAGxBC,2CAAkCnH,mBAAAA,IAAAA,GAAQ,GACjCA,GAETkF,mBAEElH,EACAoJ,aACEC,WAAAA,oBAAoB7B,kBAAuBD,KAEvC7B,EAAI/C,EAAa3C,EAAGqJ,EAAa,kCAFaxG,KAEO,EAAe,eACrEwG,WAAaA,EACX3D,GAGT4D,uBAActJ,mBAAAA,IAAAA,EApHsB,IAqH3B2C,EAAa3C,IAEtBuJ,uBAAcvJ,mBAAAA,IAAAA,EAtHsB,IAuH3B2C,EAAa3C,IAEtBwJ,uBAAcxH,mBAAAA,IAAAA,EAxHsB,KAyH3BA,GAETyH,eAAMzH,mBAAAA,IAAAA,EAA0B,GACtBA,QACD,SAjIuB,SAmIvB,SACI,iBAEAA,eAKC0H,EAA0BnG,mBAAAA,IAAAA,EAAyB,IAE1DD,EAAoDC,EAAQ2E,YASrDyB,EACdpG,mBAAAA,IAAAA,EAA+B,IAExBD,EAAiEC,EAAQ+D,YAGlEsC,EACdrG,mBAAAA,IAAAA,EAAiC,IAE1BD,EACLC,EACAgF,YAIYsB,EAAuBtG,mBAAAA,IAAAA,EAAqB,IACnDD,EAA6CC,EAAQwF,YC1K9Ce,SAAmB3B,IAAAA,UAAWC,IAAAA,aAActE,IAAAA,OAAQqD,IAAAA,QAAY4C,uDACxEC,EAAuBN,EAA0B,CAAEvB,UAAAA,EAAWC,aAAAA,EAActE,OAAAA,EAAQqD,QAAAA,WAC1F6C,EAAKC,KAAON,EAA8BI,GACnCC,WAGOE,SAAoB/B,IAAAA,UAAWC,IAAAA,aAActE,IAAAA,OAAQqD,IAAAA,QAAY4C,uDACzEC,EAAuBN,EAA0B,CAAEvB,UAAAA,EAAWC,aAAAA,EAActE,OAAAA,EAAQqD,QAAAA,WAC1F6C,EAAKG,SAAUhD,SAAS,GAAS4C,GAC1BC,WAGOI,SAAmBjC,IAAAA,UAAWC,IAAAA,aAActE,IAAAA,OAAQqD,IAAAA,QAAY4C,uDACxEC,EAAuBN,EAA0B,CAAEvB,UAAAA,EAAWC,aAAAA,EAActE,OAAAA,EAAQqD,QAAAA,WAC1F6C,EAAKK,KAAOR,EAAuBE,GAC5BC,WAGOM,SAAoBnC,IAAAA,UAAWC,IAAAA,aAActE,IAAAA,OAAQqD,IAAAA,QAAY4C,uDACzEC,EAAuBN,EAA0B,CAAEvB,UAAAA,EAAWC,aAAAA,EAActE,OAAAA,EAAQqD,QAAAA,WAC1F6C,EAAKO,MAAQX,EAAgCG,GACtCC,WAGOQ,SAAqBrC,IAAAA,UAAWC,IAAAA,aAActE,IAAAA,OAAQqD,IAAAA,QAAY4C,uDAC1EC,EAAuBN,EAA0B,CAAEvB,UAAAA,EAAWC,aAAAA,EAActE,OAAAA,EAAQqD,QAAAA,WAC1F6C,EAAKS,OAASd,EAA8BI,GACrCC,WAGOU,SAAoBvC,IAAAA,UAAWC,IAAAA,aAActE,IAAAA,OAAQqD,IAAAA,QAAY4C,uDACzEC,EAAuBN,EAA0B,CAAEvB,UAAAA,EAAWC,aAAAA,EAActE,OAAAA,EAAQqD,QAAAA,WAC1F6C,EAAKW,MAAQhB,EAA8BI,GACpCC,ECjDT,SAASY,EAAcC,aAEnBC,SAAS,EACTC,UAAU,EACVC,aAAc,EAAC,GAAO,GACtBC,UAAW,CAAC,EAAG,GACfC,SAAU,CAAC,EAAG,GACdC,QAAS,CACP,EAAE3J,SAAUA,UACZ,EAAEA,SAAUA,WAEd4J,WAAY,CAAC,EAAG,GAChBC,oBAAgBxI,EAChByI,cAAc,EACdC,oBAAoB,EACpBC,YAAY,EACZC,cAAc,EACdzH,WAAOnB,EACP6I,aAAa,EACb1F,OAAQ,CAAC,EAAG,GACZ/E,WAAY,CAAC,EAAG,GAChBT,MAAO,CAAC,EAAG,GACXJ,SAAU,CAAC,EAAG,GACduL,OAAQ,CAAC,EAAG,GACZC,WAAY,CAAC,EAAG,GAChBjL,UAAW,CAAC,EAAG,GACf0G,QAAS,CAAC,EAAG,GACbwE,SAAU,CAAC,EAAG,GACdC,OAAO,EACPC,MAAM,EACNC,QAAQ,EACRC,UAAW,EACXC,UAAW,EACXC,YAAa,EACbC,OAAQlK,EACRmK,UAAU,EACVC,UAAMzJ,EACNQ,UAAMR,GACHgI,GAIP,SAAgB0B,UA+DP,CAAEC,OA9DM,CACbC,UAAU,EACVC,WAAW,EACXC,UAAU,EACVC,UAAU,EACVC,QAAQ,EACRC,UAAU,EACVvH,QAAS,EACTd,QAAS,EACTsI,MAAM,EACNrI,UAAU,EACVC,QAAQ,EACRC,SAAS,EACTC,SAAS,EACTmI,QAAQ,GAgDO3C,KA7CJO,EAAoC,CAC/CqC,gBAAYpK,EACZ0E,UAAM1E,EACNkC,GAAI,CAAC,EAAG,GACRmI,KAAM,CAAC,EAAG,GACVlM,SAAU,EACVJ,SAAU,EACVuM,KAAK,EACLC,MAAO,CAAC,EAAG,KAqCU7C,MAlCTK,EAAuC,CAEnDyC,YAAa,GACbC,GAAI,CAAC,EAAG,GACRC,KAAM,CAAC,EAAG,GAEVpH,YAAQtD,EACR2K,MAAO,IA2BqB7C,MAxBhBC,EAAwB,CACpCrD,UAAM1E,EACNkC,GAAI,CAAC,EAAG,GACRmI,KAAM,CAAC,EAAG,GACVlM,SAAU,EACVJ,SAAU,IAmByBqJ,KAhBxBW,EAAwB,CACnCrD,UAAM1E,EACNkC,GAAI,CAAC,EAAG,GACRmI,KAAM,CAAC,EAAG,GACVlM,SAAU,EACVJ,SAAU,IAW+B6J,OAR5BG,EAAwB,CACrCrD,UAAM1E,EACNkC,GAAI,CAAC,EAAG,GACRmI,KAAM,CAAC,EAAG,GACVlM,SAAU,EACVJ,SAAU,KCtFP,IAAM6M,EAAiB,IAAIC,IAE5B5I,EAAW,SAACC,UAAgBA,GAMJ4I,wBAWPC,EAAiCvK,uBAAAA,IAAAA,EAAc,oBAA/CuK,YAAiCvK,kBATvB,kBAiDR,SAACwK,EAAoCC,kBAAAA,IAAAA,EAAa,KACvEC,aAAaC,EAAKJ,WAAWK,SAASD,EAAKE,sCADoC7K,mCAAAA,oBAE/E2K,EAAKJ,WAAWK,SAASD,EAAKE,aAAYpK,QAAOqK,oBAAWN,EAAUC,UAAOzK,uBAItD,WACvB0K,aAAaC,EAAKJ,WAAWK,SAASD,EAAKE,oCA2Fd,SAACE,eAAAA,IAAAA,GAAqB,GAK/CJ,EAAKtG,MAAMqD,gBAERiD,EAAKK,YACRL,EAAKtG,MAAMoD,SAAU,EACrBkD,EAAKM,SAEA,SAIJF,IAAcJ,EAAKtG,MAAMgE,cAAgBsC,EAAKzK,OAAO6D,iBAAkB,OAAO,QAE/E4G,EAAKtG,MAAMgE,YAAa,KACpB6C,EAAcP,EAAKtG,MAAMsE,OACzBwC,EAAcR,EAAKtG,MAAMoD,QAE/BkD,EAAKtG,MAAMsE,OAASwC,EACpBR,EAAKtG,MAAMoE,MAAQ0C,IAAgBD,EACnCP,EAAKtG,MAAMqE,KAAOwC,IAAgBC,EAElCR,EAAKJ,WAAWlG,MAAM8E,OAAOwB,EAAKS,QAAUD,MAExCjJ,EAAUyI,EAAKJ,WAAWtI,WAAWoJ,MAAQV,EAAKJ,WAAWe,SAASD,KACtE3B,EAAOiB,EAAKJ,WAAWlG,MAAM8E,OAAO/H,QAAU,GAAKc,EAAU,EAE7DmC,OACDsG,EAAKJ,WAAWlG,MAAM8E,OACtBwB,EAAKtG,MACLsG,EAAKY,eAAeZ,EAAKtG,QAC5BsF,SAAUhF,SAAS6G,mBACnBtJ,QAAAA,EACAwH,KAAAA,IAII+B,EAAUd,EAAKe,QAAQrH,UAG7BsG,EAAKtG,MAAM4E,UAAmB,IAAZwC,EAAqBA,EAAUd,EAAKtG,MAAM4E,KAErD5E,QAtLFkG,WAAaA,OACbvK,KAAOA,+BA4BJ2L,kBAAA,SAAkBC,GAC1B/L,OAAOC,OAAOV,KAAKmL,WAAWlG,MAAM8E,OAAQyC,MAIpCC,mBAAA,SAAmBC,GAC3BjM,OAAOC,OAAOV,KAAKiF,MAAOyH,MA4BlBC,oBAAA,SACRpE,EACAC,SAEO,CAAED,aAAAA,EAAcD,UAAU,MAMzBsE,YAAA,SAAYrJ,OACZ3E,EAAeoB,KAAKc,OAApBlC,aAUJoB,KAAKiF,MAPPyD,IAAAA,QACAD,IAAAA,SACAJ,IAAAA,QACcwE,IAAdtE,aACAY,IAAAA,WACU2D,IAAVnP,SACYoP,IAAZpE,WAEIqE,EAAIhN,KAAKiN,oBAAoB1J,EAAQvD,KAAKiF,OAE1CiI,GAA2B,IAAtBL,EAAe,GAAeM,GAA2BH,EAAE,GAAID,EAAG,IAAMF,EAAe,GAC5FO,GAA2B,IAAtBP,EAAe,GAAeM,GAA2BH,EAAE,GAAID,EAAG,IAAMF,EAAe,GAG5FQ,EAAsBrN,KAAK2M,oBAAoB,CAACO,EAAIE,GAAKJ,MAC3DK,EAAoB/E,qBACV+E,GAAqB7E,UAAWwE,EAAGjP,MAAO,CAAC,EAAG,SAGtDwK,EAAe8E,EAAoB9E,aACnCC,EAAYwE,EAMdrP,EAAoB,EACF,IAApB4K,EAAa,GAAeyE,EAAE,GAAKzE,EAAa,GAAK,GACjC,IAApBA,EAAa,GAAeyE,EAAE,GAAKzE,EAAa,GAAK,GAGjDW,EAAS/L,EAAKQ,EAAUwL,GAMxBmE,EAAuBjF,EAAUzJ,EAAa,CAAC,EAAG,UACxDjB,EAAW4P,GAAkB7E,EAASvL,EAAKQ,EAAU8K,GAAW6E,QAG3DD,GACHpE,aAAiC,IAApBV,EAAa,KAAoC,IAApBA,EAAa,GACvDE,SAAAA,EACAD,UAAAA,EACA7K,SAAAA,EACA4F,OAAAA,EACA2F,OAAQqE,GAAkB7E,EAASQ,EAAQoE,GAC3CvP,MAAON,EAAKE,EAAUmP,QAKhBjB,MAAA,gBACHP,wDA7HEtL,KAAKmL,WAAWrK,OAAOd,KAAKyL,iDAK5BzL,KAAKmL,WAAWrK,OAAO4D,SAAW1E,KAAKc,OAAO4D,6CAK9C1E,KAAKmL,WAAWlG,MAAMjF,KAAKyL,iDAK3BzL,KAAKmL,WAAWqC,SAASxN,KAAKyL,mDAI9BzL,KAAKc,OAAO0B,WAAaxC,KAAKmL,WAAWrK,OAAO0B,WAAaH,gMAmKxE,SAAS8K,GAA2BxP,EAAkB8G,UAChD7G,KAAKoB,IAAIrB,IAAa8G,GACjBhG,EAAKd,GAAY8G,EAM5B,SAAS8I,GAAkBvI,WAAiCyI,OAAmBC,SAChD1I,OAAAA,KAAX2I,OAAIC,aAEf,CAACzO,uBAAyCA,EAAwBsO,EAAIE,EAAIC,EAAIF,IAMvF,SAAgBG,KAEdtM,EACAuM,OAFE7I,IAAAA,MAIMuE,EAAoCjI,EAApCiI,gBAGD,CAAEZ,eAHmCrH,EAAzBC,KAGMD,MAAAA,EAAOiI,UAAAA,EAAWE,YADvBoE,EAAe,EAAItE,EAAYvE,EAAMwE,UACDL,SAFvCnE,EAAM1B,QASzB,SAAgBwK,KAEdxK,EACAhC,EACAqD,OAHS9D,IAAAA,OAAQ2K,IAAAA,SAAU7K,IAAAA,KAAM4B,IAAAA,UAK3B0G,IALJjE,MAKmBiE,OACfO,EAAYlI,EAAMiI,UAEPwE,EAAiClN,EAA1C8D,QAAoBI,EAAsBlE,EAAtBkE,OAItB2D,EAAalL,EAAK+E,EAJ0B1B,EAAd2D,WAIUjC,EAAU,CAAC,EAAG,KAAKlF,IAAIM,KAAKoB,KAEpEiP,OACDnE,IAAkB2B,IACrBpD,SAAS,EACTzH,KAAAA,EACA2C,OAAAA,EACAqB,cAASA,EAAAA,EAAWrB,EACpBoF,WAAAA,EACAO,OAAAA,EACAC,WAAYD,EACZO,UAAAA,gBAGUwE,GAAQxF,SAAU9H,EAAQqN,EAAWC,GAASvF,QAAS/H,EAAQqE,EAAQiJ,SC5QhEC,GAcnB,SAAoBC,2BAAAA,kBALA,IAAIC,kBACN,IAAIA,6BACOhN,+BLvB/B,qBAIW,gBAAiBiN,aACxB,MAAOC,UACA,GKkBsBC,aAUjB,sCAAI3N,2BAAAA,4BACV4N,EAA0C,OAEpBjD,EAAK4C,6BAAxBM,cAAqCA,EAAgBlD,EAAM3K,GAAM8N,YAAYF,kBAG7EG,GACPD,GAAYF,EAAUG,GAAU,SAACpN,UAAegK,EAAKqD,WAAWD,QAAepD,EAAKtG,MAAM8E,QAAQxI,MAAAA,EAAOX,KAAAA,aADtG,IAAI+N,KAAYpD,EAAKqD,aAAjBD,UAILpD,EAAKzK,OAAO4E,UAEPmJ,GAAmBtD,EAAMiD,GAGzBM,GAAiBvD,EAAMiD,gBAIlB,kBACVjD,EAAKzK,OAAO4E,WAAW6F,EAAKwD,OACzBxD,EAAKM,kBAMC,eACPnG,EAAYsJ,GAAuBzD,EAAKzK,QACtC6E,EAAiB4F,EAAKzK,OAAtB6E,aACJD,GAAWuJ,GAAgBvJ,EAAWwJ,GAAQ3D,EAAK4D,cAAexJ,GACtElF,OAAO8C,OAAOgI,EAAKC,UAAU4D,QAAQ9D,uBA2BDH,SAIlCA,EAFFrK,OAAkBuO,IAARhO,OAAYsE,IAAAA,aACtB2J,EACEnE,EADFmE,mBAEGD,OAEA,IAAI5D,KAAY6D,EAEnBL,GAAgBI,EADCC,EAAgB7D,GACH9F,GAGhCwF,EAAWmE,gBAAkB,IAtC3BC,CAAwBhE,SAvCnB4C,QAAUA,OACVlJ,MAAQ6E,SACR0B,SAAW,QACX2D,aAAe,QACfG,gBAAkB,aAuCXE,GACdrE,EACA5J,GAEI,cAAeA,EACjB4J,EAAWtI,WAAW4M,IAAIlO,EAAMmO,WAEhCvE,EAAWe,SAAW,IAAIkC,IAAIzM,EAAYJ,aAI9BoO,GACdxE,EACA5J,GAEI,cAAeA,EACjB4J,EAAWtI,kBAAkBtB,EAAMmO,WAEnC/N,EAAYJ,GAAO6N,SAAQ,SAAAQ,UAAMzE,EAAWe,gBAAgB0D,MAmBhE,SAAgBC,KAEdpE,EACAqE,OAFEhP,IAAAA,OAAQwO,IAAAA,yBAEVQ,IAAAA,EAAUhP,EAAO6E,cAEZ7E,EAAOO,SACZ4N,GAAgBnO,EAAOO,OAAQiO,EAAgB7D,GAAWqE,UACnDR,EAAgB7D,IAGzB,SAAgBsE,KAEdtE,EACAuE,EACAF,OAHEhP,IAAAA,OAAQwO,IAAAA,yBAEVU,IAAAA,EAA4B,aAC5BF,IAAAA,EAAUhP,EAAO6E,cAEZ7E,EAAOO,SACZ4N,GAAgBnO,EAAOO,OAAQiO,EAAgB7D,GAAWqE,GAC1DG,GAAanP,EAAOO,OAASiO,EAAgB7D,GAAYuE,EAAYF,IAGvE,SAASjB,KAAyDL,OAApC1N,IAAAA,OAAQqO,IAAAA,aAC9BzJ,EAAYsJ,GAAuBlO,OACpC4E,EAAW,MAAM,IAAIrF,MAAM,iCACxBsF,EAAiB7E,EAAjB6E,aAERsJ,GAAgBvJ,EAAWwJ,GAAQC,GAAexJ,iBAE3BlF,OAAOO,QAAQwN,kBAAW,YAAlC7O,OACPuQ,OAAWC,MAAM,GAAGC,cAC1BjB,EAAakB,KAAK,CAACH,EAAMxQ,eAAYC,KAGvCsQ,GAAavK,EAAWyJ,EAAcxJ,GAGxC,SAASmJ,KAAyCN,WAC1C8B,EAA4B,GAC5BC,IAFoBzP,OAEG6E,aAAaE,QAAU,UAAY,SACvCpF,OAAOO,QAAQwN,kBAAW,YAAzCjN,OAAO5B,OACT6Q,EAAWlQ,MAAMC,QAAQZ,GAAOA,EAAM,CAACA,GAE7C2Q,EADa/O,EAAQgP,GACR7Q,eAAa8Q,UAErBF,EAGT,SAASpB,GAAWuB,mBAAAA,IAAAA,EAAkB,IAC7BA,EAAMC,OAAO,EAAGD,EAAM7Q,QAG/B,SAASoP,UAAyBtJ,IAAAA,iBACzBA,GAAa,YAAaA,EAAYA,EAAUiL,QAAUjL,EASnE,SAAgBgJ,GAAYF,EAAe0B,EAAcpQ,GAClD0O,EAAS0B,KAAO1B,EAAS0B,GAAQ,IACtC1B,EAAS0B,GAAOG,KAAKvQ,GAGvB,SAASmQ,GAAaZ,EAAiBW,EAAqCF,YAArCE,IAAAA,EAAiC,aAAIF,IAAAA,EAAU,kBAC9CE,kBAAW,eAC/CX,EAAGuB,2BAA0Cd,IAIjD,SAASb,GAAgBI,EAAiBW,EAAqCF,YAArCE,IAAAA,EAAiC,aAAIF,IAAAA,EAAU,kBACjDE,kBAAW,eAC/CX,EAAGwB,8BAA6Cf,ICrKpD,SAAwBgB,GACtBtD,EACA1M,EACAiQ,YAAAA,IAAAA,EAA0C,QAEpC5C,EAwBR,SAAwB6C,OAChB7C,EAAU,IAAIC,WAEhB4C,EAAiBpJ,MAAMuG,EAAQsB,IAAIzE,EAAeiG,IAAI,SACtDD,EAAiB9I,OAAOiG,EAAQsB,IAAIzE,EAAeiG,IAAI,UACvDD,EAAiBhJ,QAAQmG,EAAQsB,IAAIzE,EAAeiG,IAAI,WACxDD,EAAiBxJ,MAAM2G,EAAQsB,IAAIzE,EAAeiG,IAAI,SACtDD,EAAiBlJ,OAAOqG,EAAQsB,IAAIzE,EAAeiG,IAAI,UACvDD,EAAiBtJ,OAAOyG,EAAQsB,IAAIzE,EAAeiG,IAAI,UAEpD9C,EAlCS+C,CAAe1D,GAEzBrC,EAAagG,EAAMC,SAAQ,kBAAM,IAAIlD,GAAWC,KAAU,WAChEhD,EAAYrK,OAASA,EACrBqK,EAAYqC,SAAWA,EACvBrC,EAAYyD,WAAamC,EAEzBI,EAAME,UAAUlG,EAAWmG,OAAQ,IAG/BnG,EAAWrK,OAAO4E,UAAkB6L,GAEjCpG,EAAW4D,KAGpB,SAASwC,UClCqBC,mGAIlBvE,oBAAA,SAAoB1J,EAAiB0B,UACtCxH,EAAK8F,EAAQ0B,EAAML,YAQlB+H,oBAAA,SACRpE,EACAC,OAEwB,IAApBD,EAAa,KAAoC,IAApBA,EAAa,SACrC,CAAEA,aAAAA,EAAczD,KAAM9E,KAAKiF,MAAMH,YAErB0D,EAAUlL,IAAIM,KAAKoB,KAAjCyS,OAAMC,OACP5M,EAAO9E,KAAKiF,MAAMH,OAAS2M,EAAOC,EAAO,IAAMD,EAAOC,EAAO,SAAMtR,UACpEJ,KAAKc,OAAOgE,MAAS9E,KAAKc,OAAOiE,cACjCD,EACC9E,KAAKc,OAAOgE,MAAQA,IAAS9E,KAAKc,OAAOgE,KAAa,CAAEyD,aAAAA,EAAcD,UAAU,EAAMxD,KAAAA,IAC5FyD,EAAuB,MAATzD,EAAe,EAAI,IAAK,EAC/B,CAAEyD,aAAAA,EAAcD,UAAU,EAAOxD,KAAAA,IAHtB,CAAEyD,aAAc,EAAC,GAAO,GAAQD,UAAU,EAAOxD,KAAAA,GADP,CAAEyD,aAAAA,EAAcD,UAAU,EAAOxD,KAAAA,MAO/F6M,cAAA,SAAcpO,EAAiBhC,OACvB0D,EAAQjF,KAAK4M,YAAYrJ,UAC1B0B,EAAMqD,UAET7H,OAAOC,OAAOuE,EAAO7G,EAAuB6G,EAAMtH,SAAWsH,EAAMlH,MADxDwD,EAAMiI,UAAYxJ,KAAKiF,MAAMuE,YAGnCvE,KAGCkH,eAAA,SAAelH,SAChB,CAAE3C,GAAI2C,EAAM1B,OAAQkH,KAAMxF,EAAMzG,gBAvC2C0M,GCCtF,SAAS0G,GAAarQ,eACPA,GAAkC,mBAAlBA,EAAMsQ,SAA0BtQ,EAAMsQ,cAGxDC,iFACO,sBACE,2BAIQ,SAACvQ,OAGvBgK,EAAKzK,OAAOyF,WAAYhB,SAAS6G,wBAE7B2F,EAAsBxQ,EAAtBwQ,OAAQrC,EAAcnO,EAAdmO,UACZqC,GAAU,sBAAuBA,GAInCA,EAAOC,kBAAkBtC,KAEtBjD,mBAAmB,CAAEwF,YAAaF,EAAQG,eAAgBxC,8BAGjC,eAC1BnE,EAAKzK,OAAOyF,WAAYhB,SAAS6G,0BAEGb,EAAKtG,MAArCgN,IAAAA,YAAaC,IAAAA,kBACjBA,GAAkBD,GAAe,0BAA2BA,MAGxD,sBAAuBA,IAAgBA,EAAYE,kBAAkBD,IACzE,IACED,EAAYG,sBAAsBF,GAClC,MAAO5D,uBAIS,SAAC/M,GACnBgK,EAAKtG,MAAM6D,oBAAsBvH,EAAM8Q,YACzC9Q,EAAM+Q,+BAIW,SAAC/Q,UAChBgK,EAAKzK,OAAOyF,SAAiBhF,EAAME,eAAe,GAAGK,WAClDP,EAAMmO,0BAGQ,SAACnO,UAEfgK,EAAKtG,MAAMuF,aAAee,EAAKgH,WAAWhR,iCAIjDgK,EAAKzK,OAAO4F,mCAAqC6E,EAAKJ,WAAW/J,iDAE9B,SAACG,GACpCqQ,GAAarQ,GAEbwO,GACExE,EAAKJ,WACLI,EAAKE,SACL,CACE,CAAC,YAAaF,EAAKiH,eACnB,CAAC,WAAYjH,EAAKM,MAAMkD,YACxB,CAAC,cAAexD,EAAKM,MAAMkD,aAE7B,CAAEnJ,SAAS,MAER8F,WAAWH,EAAKkH,UAAU1D,WAAY,IAAKxN,8BAGhB,SAACA,KAC5B0D,MAAM+D,cAAe,EAC1B4I,GAAarQ,KACRmK,WAAWH,EAAKkH,UAAU1D,WAAYxD,EAAKzK,OAAOkG,MAAOzF,oBAGxC,SAACA,OACjBgC,EAAShB,EAAsBhB,EAAOgK,EAAK/I,aAC5C+J,kBAAkBxK,EAAoBR,MAEtCkL,wBACAsB,QAA2BxK,EAAQhC,GACnCsM,QAAwBtM,GAAO,IAClCiJ,WAAYe,EAAKgH,WAAWhR,QAGzBkL,mBAAmBlB,EAAKqB,YAAYrJ,mBAG7B,SAAChC,GACbiO,GAAYjE,EAAKJ,WAAY5J,GACxBgK,EAAK7G,UAAW6G,EAAKtG,MAAMoD,YAE3BqK,cAAcnR,KACdyQ,kBAAkBzQ,GAEnBgK,EAAKoH,2BAA4BpH,EAAKqH,2BAA2BrR,GAC5DgK,EAAKzK,OAAOkG,MAAQ,EAAGuE,EAAKsH,wBAAwBtR,GACxDgK,EAAKkH,UAAUlR,GAAO,oBAqBd,SAACA,SAGP0D,MAAM2E,UAEV2B,EAAKtG,MAAMoD,SAEXkD,EAAKuH,aAAavR,OAGb0D,MAAM2D,iBAAmBrH,EAAMC,MAAQD,EAAMiI,YAAc+B,EAAKtG,MAAMuE,gBAI1EjG,EAIFA,EAFEgC,SAAS6G,mBAEFjP,EAAKoO,EAAK/I,UAAU,CADIjB,EAAzBwR,UAAyBxR,EAAdyR,YACmCzH,EAAKtG,MAAM1B,QACnDhB,EAAsBhB,EAAOgK,EAAK/I,eAE5CyQ,EAAa1H,EAAKoG,cAAcpO,EAAQhC,OAGzCgK,EAAKtG,MAAM4D,aAAc,IAIxB0C,EAAKtG,MAAM+D,2BACRyJ,UAAUlR,OAIbgK,EAAKoH,2BAUF,UATApH,EAAKtG,MAAM6D,qBAAsBmK,EAAWnO,KAQ1C,UANmB,MAApBmO,EAAWnO,mBAGRG,MAAMoD,SAAU,KAFhBoK,UAAUlR,OASjB2R,EAAmBnR,EAAoBR,KAExCgL,kBAAkB2G,OACjBC,EAAiBtF,QAAwBtM,GAKzC6R,EAAe1V,EAAkBuV,EAAWzK,WAC5CO,EAAewC,EAAKtG,MAApB8D,WACFA,GAAcqK,GAtLgB,IAsLwBrK,GAAa,KAElE0D,wBAAwB0G,EAAmBF,GAAYlK,WAAAA,OAEvDsK,mCAGK,SAAC9R,MACXoO,GAAepE,EAAKJ,WAAY5J,GAI3BgK,EAAKuH,aAAavR,OAClBsK,QAIAN,EAAKtG,MAAMoD,YACXpD,MAAMoD,SAAU,MAEfqC,EAAMa,EAAKtG,MAAM8D,aACNwC,EAAKtG,MAAMzG,WAArB8U,OAAIC,SACMhI,EAAKtG,MAAMtH,SAArB6V,OAAIC,SACMlI,EAAKtG,MAAMsD,aAArBmL,OAAIC,SACQpI,EAAKzK,OAAO+F,cAAxB+M,OAAKC,SACKtI,EAAKzK,OAAOgG,cAAtBgN,OAAIC,OACLC,EAAKzI,EAAKzK,OAAOiG,cAEjBkN,OACDpG,QAAwBtM,GACxBgK,EAAKqB,YAAYrB,EAAKtG,MAAM1B,SAG3BoH,EAA0B,CAAC,EAAG,GAEhCsJ,EAASvK,YAAcsK,KACd,IAAPN,GAAgB9V,KAAKoB,IAAIsU,GAAMM,GAAOhW,KAAKoB,IAAIwU,GAAMM,IAAInJ,EAAM,GAAKlM,EAAK6U,KAClE,IAAPK,GAAgB/V,KAAKoB,IAAIuU,GAAMM,GAAOjW,KAAKoB,IAAIyU,GAAMM,IAAIpJ,EAAM,GAAKlM,EAAK8U,OAG1EhH,kBAAkB,CAAEvK,QAAS,MAC7ByK,wBAAwBwH,GAAUvJ,IAAAA,EAAKC,MAAAA,OACvC0I,mBAAmB9H,EAAKzK,OAAO8F,aAAsB,IAAR8D,aAG5C,uBACAmB,mBACD5G,MAAM4D,cAAe,IACrBuJ,wBACLvC,GAAqBtE,EAAKJ,WAAYI,EAAKE,sBAGlC,WACLF,EAAKtG,MAAM2E,aACV6C,mBAAmB,CAAE7C,UAAU,EAAMvB,SAAS,MAC9CkE,kBAAkB,CAAEvK,QAAS,IAClC0J,YAAW,kBAAMH,EAAK8H,uBAAsB,eAGpC,SAAC9R,GACJgK,EAAKtG,MAAM8D,YAAYxH,EAAM2S,uDAtIpCzB,UAAA,SAAUlR,EAA0C4S,YAAAA,IAAAA,GAAyB,GAMxEnU,KAAKiF,MAAMoD,eAEPpD,MAAM4D,eAIRsL,GAAenU,KAAK0S,cAAcnR,QAClCkL,mBAAmB,CAAE5D,cAAc,EAAMC,oBAAoB,EAAMa,OAAQ3J,KAAKoU,gBAChF9I,oBACA+H,yBA0HP3E,YAAA,SAAYF,GACNxO,KAAKc,OAAOyF,UACdmI,GAAYF,EAAU,eAAgBxO,KAAKqU,aAC3C3F,GAAYF,EAAU,cAAexO,KAAKsU,cAC1C5F,GAAYF,EAAU,aAAcxO,KAAKuU,WACzC7F,GAAYF,EAAU,gBAAiBxO,KAAKuU,aAE5C7F,GAAYF,EAAU,gBAAiBxO,KAAKqU,aAC5C3F,GAAYF,EAAU,gBAAiBxO,KAAKsU,cAC5C5F,GAAYF,EAAU,cAAexO,KAAKuU,WAC1C7F,GAAYF,EAAU,kBAAmBxO,KAAKuU,YAG5CvU,KAAKc,OAAO8F,YAEd8H,GAAYF,EADIxO,KAAKmL,WAAWrK,OAAO6E,aAAaE,QAAU,UAAY,iBAC3C7F,KAAKwU,aA7PNhD,aCPZiD,GACtBC,EACAC,OAEIC,EAEAC,EADAC,EAAsB,GAEtBC,GAAsB,+CAEUC,2BAAAA,yBAC9BD,GAAcH,IAAa5U,MAAQ2U,EAAQK,EAASF,KAIxDD,EAAaH,EAAS3U,MAAMC,KAAMgV,GAClCD,GAAa,EACbH,EAAW5U,KACX8U,EAAWE,GANFH,YC4CWF,GAAQM,EAAQC,cAvDxC,SAASC,EAAMF,EAAQC,MACjBD,IAAMC,EAAG,OAAO,KAEhBD,GAAKC,GAAiB,iBAALD,GAA6B,iBAALC,EAAe,IACtDD,EAAEG,cAAgBF,EAAEE,YAAa,OAAO,MAExCxV,EAAQpC,EAAG6X,EAQXC,KAPAhV,MAAMC,QAAQ0U,GAAI,KACpBrV,EAASqV,EAAErV,UACIsV,EAAEtV,OAAQ,OAAO,MAC3BpC,EAAIoC,EAAgB,GAARpC,SAAkB2X,EAAMF,EAAEzX,GAAI0X,EAAE1X,IAAK,OAAO,SACtD,KAIU,mBAARyN,KAAsBgK,aAAahK,KAAOiK,aAAajK,IAAK,IACjEgK,EAAEhJ,OAASiJ,EAAEjJ,KAAM,OAAO,MAC9BqJ,EAAKL,EAAEjU,YACExD,EAAI8X,EAAGC,QAAQC,UAAWN,EAAEO,IAAIjY,EAAE+B,MAAM,IAAK,OAAO,MAC7D+V,EAAKL,EAAEjU,YACExD,EAAI8X,EAAGC,QAAQC,UAAWL,EAAM3X,EAAE+B,MAAM,GAAI2V,EAAEjE,IAAIzT,EAAE+B,MAAM,KAAM,OAAO,SACzE,KAGU,mBAAR6O,KAAsB6G,aAAa7G,KAAO8G,aAAa9G,IAAK,IACjE6G,EAAEhJ,OAASiJ,EAAEjJ,KAAM,OAAO,MAC9BqJ,EAAKL,EAAEjU,YACExD,EAAI8X,EAAGC,QAAQC,UAAWN,EAAEO,IAAIjY,EAAE+B,MAAM,IAAK,OAAO,SACtD,KAGL0V,EAAEG,cAAgBM,OAAQ,OAAOT,EAAEU,SAAWT,EAAES,QAAUV,EAAEW,QAAUV,EAAEU,SACxEX,EAAEY,UAAYpV,OAAOqV,UAAUD,QAAS,OAAOZ,EAAEY,YAAcX,EAAEW,aACjEZ,EAAEc,WAAatV,OAAOqV,UAAUC,SAAU,OAAOd,EAAEc,aAAeb,EAAEa,eAGxEnW,GADAyV,EAAO5U,OAAO4U,KAAKJ,IACLrV,UACCa,OAAO4U,KAAKH,GAAGtV,OAAQ,OAAO,MAExCpC,EAAIoC,EAAgB,GAARpC,SAAkBiD,OAAOqV,UAAUE,eAAe7U,KAAK+T,EAAGG,EAAK7X,IAAK,OAAO,KAErE,oBAAZyY,SAA2BhB,aAAagB,QAAS,OAAO,MAE9DzY,EAAIoC,EAAgB,GAARpC,UACC,WAAZ6X,EAAK7X,IAAmByX,EAAEiB,UACzBf,EAAMF,EAAEI,EAAK7X,IAAK0X,EAAEG,EAAK7X,MAAM,OAAO,SAEtC,SAKFyX,GAAMA,GAAKC,GAAMA,EAKfC,CAAMF,EAAGC,GAChB,MAAOiB,OACFA,EAAMC,SAAW,IAAIC,MAAM,2BAE9BC,QAAQC,KAAK,mDACN,QAEHJ,OCvDGK,iFACO,sBACE,uBAEL,SAACjV,GACdiO,GAAYjE,EAAKJ,WAAY5J,OACvB2K,EAAWX,EAAKJ,WAAWe,YAE5BX,EAAK7G,WAEN6G,EAAKtG,MAAMoD,SAITkD,EAAKtG,MAAM2F,YAAY6L,OAAM,SAAA7G,UAAM1D,EAASuJ,IAAI7F,OAIlD1D,EAASD,KAAO,QACdrB,EAActK,MAAMsB,KAAKsK,GAAUiE,MAAM,EAAG,KAEvBvN,EAAyBrB,EAAOqJ,EAAaW,EAAK/I,WAArEe,IAAAA,OAAQG,IAAAA,SAEX6I,kBAAkBxK,EAAoBR,MAEtCkL,wBACAsB,QAA2BxK,EAAQhC,GACnCsM,QAAwBtM,GAAO,IAClCqJ,YAAAA,EACAjB,OAAQ4B,EAAK6I,SACb1Q,OAAAA,OAGG+I,mBAAmBlB,EAAKqB,YAAYrJ,MACpC8P,uCAGS,SAAC9R,SACegK,EAAKtG,YAA3B2E,YAAUvB,SAKhB9G,EAAMiI,YAAc+B,EAAKtG,MAAMuE,eAG3B0J,EAAmBnR,EAAoBR,KAExCgL,kBAAkB2G,aAEMtQ,EAAyBrB,EAAOgK,EAAKtG,MAAM2F,YAAaW,EAAK/I,WAAxEkB,IAAAA,OACVuP,EAAa1H,EAAKoG,gBADhBpO,OACsChC,KAEzCkL,wBACAoB,QAAwBtM,GACxB0R,GACHvP,OAAAA,OAGG2P,qBACL,MAAO/E,KACFoI,WAAWnV,mBAIP,SAACA,GACZoO,GAAepE,EAAKJ,WAAY5J,OAC1BsB,EAAalB,EAAYJ,GAG3BgK,EAAKtG,MAAM2F,YAAY6L,OAAM,SAAA7G,UAAO/M,EAAWG,SAAS4M,UAEvD/D,QACAN,EAAKtG,MAAMoD,YAEXoE,wBACAoB,QAAwBtM,GACxBgK,EAAKqB,YAAYrB,EAAKtG,MAAM1B,SAC/B8E,SAAS,OAENgL,mCAGI,WACL9H,EAAKtG,MAAM2E,aACV6C,mBAAmB,CAAEpE,SAAS,EAAOuB,UAAU,IACpD8B,YAAW,kBAAMH,EAAK8H,uBAAsB,sBAK7B,SAAC9R,MACXgK,EAAK7G,SACVnD,EAAM+Q,qBAEA/O,EAASc,EAA4B9C,EAAOgK,EAAK/I,aAElD+J,kBAAkBxK,EAAoBR,MAEtCkL,wBACAsB,QAA2BxK,EAAQhC,GACnCsM,QAAwBtM,GAAO,IAClCmC,OAAQ,CAACnC,EAAMmB,QAASnB,EAAMoB,SAC9BgH,OAAQ4B,EAAK6I,cAGV3H,mBAAmBlB,EAAKqB,YAAYrJ,MACpC8P,yCAGW,SAAC9R,SACagK,EAAKtG,YAA3B2E,YAAUvB,SAGlB9G,EAAM+Q,qBAEAY,EAAmBnR,EAAoBR,KAExCgL,kBAAkB2G,OAIjB3P,EAASc,EAA4B9C,EAAOgK,EAAK/I,WACvDe,EAAO,GA7H0B,KA8H9BA,EAAO,GAAMgI,EAAKtG,MAAM1D,MAA6B+C,OAAwCiH,EAAKtG,MAAM1B,OAAO,OAE5G0P,EAAa1H,EAAKoG,cAAcpO,EAAQhC,KAEzCkL,wBACAoB,QAAwBtM,GACxB0R,GACHvP,OAAQ,CAACnC,EAAMmB,QAASnB,EAAMoB,cAG3B0Q,sCAGQ,SAAC9R,KACTsK,QACAN,EAAKtG,MAAMoD,YAEXoE,wBACAoB,QAAwBtM,GACxBgK,EAAKqB,YAAYrB,EAAKtG,MAAM1B,SAC/B8E,SAAS,EACT3E,OAAQ,CAACnC,EAAMmB,QAASnB,EAAMoB,cAE3B0Q,wCAMkB,SAAC9R,UACjBgK,EAAK7G,SAAWnD,EAAMa,mCAGG,SAACb,SACb0C,EAAoB1C,EAAOgK,EAAK/I,aAGhD+I,EAAKtG,MADP1B,OAAiBoT,OAGbC,EAtKY,QAyKZ3B,OAAe,IAAX0B,EAAoBA,EAAS,QAEhC,CACLpT,OAAQ,MAJSqT,EAIL3B,GACZvR,OAAQ,CAACnC,EAAMmB,QAASnB,EAAMoB,SAC9B5E,MAAO,CAAC6Y,EAAU3B,eAIZ,SAAC1T,GACJgK,EAAKsL,eAAetV,OACpBmK,WAAWH,EAAKuL,YAEhBvL,EAAKtG,MAAMoD,QACXkD,EAAKwL,cAAcxV,GADCgK,EAAKyL,aAAazV,oBAI9B,SAACA,SACoBgK,EAAK0L,wBAAwB1V,GAAvDgC,IAAAA,OAAQxF,IAAAA,MAAO2F,IAAAA,OAEnBnC,EAAM8Q,YAAY9Q,EAAM+Q,mBAQvB/F,kBAAkBxK,EAAoBR,MAEtCkL,wBACAsB,QAA2BxK,EAAQhC,EAAOgK,EAAKtG,MAAM1B,QACrDsK,QAAwBtM,GAAO,IAClC2H,OAAQ3F,EACRxF,MAAAA,EACA2F,OAAAA,OAGG+I,mBAAmBlB,EAAKqB,YAAYrJ,MACpC8P,sCAGS,SAAC9R,GACXA,EAAM8Q,YAAY9Q,EAAM+Q,mBAEvB/F,kBAAkBxK,EAAoBR,UACTgK,EAAK0L,wBAAwB1V,GAAvDgC,IAAAA,OAAQG,IAAAA,OAAQ3F,IAAAA,QAEnB0O,wBACAoB,QAAwBtM,GACxBgK,EAAKoG,cAAcpO,EAAQhC,IAC9BmC,OAAAA,EACA3F,MAAAA,OAGGsV,mCAGM,aACNxH,QACAN,EAAKtG,MAAMoD,YACXpD,MAAMoD,SAAU,IAChBoE,mBAAmBlB,EAAKqB,YAAYrB,EAAKtG,MAAM1B,WAC/C8P,mDAGP3E,YAAA,SAAYF,GAIRxO,KAAKmL,WAAWrK,OAAO4E,YACtB1F,KAAKmL,WAAW/J,qBACjBpB,KAAKmL,WAAWoD,uBAEhBG,GAAYF,EAAU,iBAAkBxO,KAAKkX,gBAC7CxI,GAAYF,EAAU,kBAAmBxO,KAAKmX,iBAC9CzI,GAAYF,EAAU,eAAgBxO,KAAKoX,gBAE3C1I,GAAYF,EAAU,eAAgBxO,KAAKqX,cAC3C3I,GAAYF,EAAU,cAAexO,KAAKsX,eAC1C5I,GAAYF,EAAU,aAAcxO,KAAK0W,YACzChI,GAAYF,EAAU,gBAAiBxO,KAAK0W,YAC5ChI,GAAYF,EAAU,UAAWxO,KAAKuX,8GC9PhCtK,oBAAA,SAAoB1J,EAA2B0B,OACjD0R,EAAS1R,EAAM1B,OAAO,GAEvBiU,EAAiBjU,OAAAA,KAAd0R,aAAI0B,IAERc,EAAUxC,EAAI0B,EACde,EAAazS,EAAM8F,aACnBnN,KAAKoB,IAAIyY,GAAW,MAAKC,GAAcjZ,EAAKgZ,IACzCha,EAAK,CAAC+Z,EAAGvC,EAAI,IAAMyC,GAAazS,EAAML,YAG/C+M,cAAA,SAAcpO,EAAiBhC,OACvB0D,EAAQjF,KAAK4M,YAAYrJ,aAItBwH,OAHMxH,EAAO,GAAK0B,EAAMuD,UAAW,GAAKxI,KAAKiF,MAAML,QAAQ,IAAM,KAGvDK,IAD2B7G,EAAuB6G,EAAMtH,SAAWsH,EAAMlH,MADjFwD,EAAMiI,UAAYxJ,KAAKiF,MAAMuE,wCAKhC2C,eAAA,SAAelH,SAChB,CAAE4F,GAAI5F,EAAM1B,OAAQuH,KAAM7F,EAAMzG,gBArB+C0M,ICD7EyM,iFACO,sBACE,qBACR,gBAEE,SAACpW,QACTA,EAAMa,WAAW,UAAWmJ,EAAKJ,WAAWqC,YAC3CjC,EAAK7G,WAELgH,WAAWH,EAAKqM,SAChBrL,kBAAkBxK,EAAoBR,QAErCgC,EAASpG,EAAK8G,EAAoB1C,EAAOgK,EAAK/I,WAAY+I,EAAKtG,MAAM1B,WAEtEgI,EAAKtG,MAAMoD,UAYToE,wBACAoB,QAAwBtM,GACxBgK,EAAKoG,cAAcpO,EAAQhC,SAdT,GAClBkL,wBACAsB,QAA2BxK,EAAQhC,EAAOgK,EAAKtG,MAAM1B,QACrDsK,QAAwBtM,GAAO,SAG9B5D,EAAW4N,EAAKqB,YAAYrJ,GAC5BsU,EAAW/Z,EAAqBH,EAASI,SAE1C0O,mBAAmB9O,KACnB8O,mBAAmBoL,KAQrBxE,+BAGC,gBACDxH,QACAN,EAAKtG,MAAMoD,aACV1K,EAAW4N,EAAKqB,YAAYrB,EAAKtG,MAAM1B,UACxCkJ,mBAAmB9O,KACnB8O,mBAAmB,CAAEpE,SAAS,EAAO7J,WAAY,CAAC,EAAG,GAAID,SAAU,MACnE8U,mDAGP3E,YAAA,SAAYF,GACVE,GAAYF,EAAU,UAAWxO,KAAK8X,iBA7CLtG,ICFxBuG,iFACO,oBACE,oBAER,WAEH,SAACxW,GACHgK,EAAK7G,YACLgH,WAAWH,EAAKyM,WAEhBzM,EAAKtG,MAAMoD,QACXkD,EAAK0M,aAAa1W,GADEgK,EAAK2M,YAAY3W,mBAI9B,SAACA,KACRgL,kBAAkBxK,EAAoBR,QACrCgC,EAAShB,EAAsBhB,EAAOgK,EAAK/I,aAE5CiK,wBACAsB,QAA2BxK,EAAQhC,GACnCsM,QAAwBtM,GAAO,OAG/BkL,mBAAmBlB,EAAKqB,YAAYrJ,MACpC8P,qCAGQ,SAAC9R,KACTgL,kBAAkBxK,EAAoBR,QACrCgC,EAAShB,EAAsBhB,EAAOgK,EAAK/I,aAE5CiK,wBACAoB,QAAwBtM,GACxBgK,EAAKoG,cAAcpO,EAAQhC,OAG3B8R,kCAGK,aACLxH,QACAN,EAAKtG,MAAMoD,YAEXoE,mBAAmBlB,EAAKqB,YADdrB,EAAKtG,MAAM1B,WAErBkJ,mBAAmB,CAAEjO,WAAY,CAAC,EAAG,GAAID,SAAU,EAAG8J,SAAS,MAC/DgL,wCAGU,kBACR9H,EAAKJ,WAAWrK,OAAO4G,MAAOlF,WAAa+I,EAAKJ,WAAWrK,OAAO0B,4BAG1D,SAACjB,QACX4J,WAAWlG,MAAM8E,OAAOC,UAAW,EACnCuB,EAAKJ,WAAWrK,OAAO4D,YAExB6G,EAAKJ,WAAWrK,OAAO4G,MAAOhD,QAAS,KACnCnB,EAAShB,EAAsBhB,EAAOgK,EAAK4M,kBAE3ClT,OACDsG,EAAKJ,WAAWlG,MAAM8E,OACtBwB,EAAKtG,MACL4I,QAAwBtM,GAAO,IAClCX,KAAM2K,EAAK3K,KACX2C,OAAAA,EACAgG,QAAQ,EACRS,UAAU,MAGPmB,WAAWqC,SAAS9F,WAAYzC,EAAUsG,EAAKY,eAAelH,KAGjE,SAAUsG,EAAKJ,WAAWqC,UAAUjC,EAAK2M,YAAY3W,sBAG1C,SAACA,QACX4J,WAAWlG,MAAM8E,OAAOC,UAAW,EACpC,SAAUuB,EAAKJ,WAAWqC,UAAUjC,EAAKyM,YACxCzM,EAAKJ,WAAWrK,OAAO4G,MAAOhD,aAE7BnB,EAAShB,EAAsBhB,EAAOgK,EAAK4M,kBAE3ClT,OACDsG,EAAKJ,WAAWlG,MAAM8E,OACtBwB,EAAKtG,MACL4I,QAAwBtM,IAC3BX,KAAM2K,EAAK3K,KACX2C,OAAAA,EACAgG,QAAQ,MAGL4B,WAAWqC,SAAS9F,WAAYzC,EAAUsG,EAAKY,eAAelH,mCAGrEyJ,YAAA,SAAYF,GACN,SAAUxO,KAAKmL,WAAWqC,UAC5BkB,GAAYF,EAAU,gBAAiBxO,KAAKoY,QAE1C,UAAWpY,KAAKmL,WAAWqC,WAC7BkB,GAAYF,EAAU,iBAAkBxO,KAAKqY,gBAC7C3J,GAAYF,EAAU,iBAAkBxO,KAAKsY,qBApGf9G,ICCvB+G,iFACO,uBACE,sBACR,gBAEE,SAAChX,MACRgK,EAAK7G,WAEL4G,iBACAI,WAAWH,EAAKqM,WAEfrU,EAASI,EAAqBpC,EAAOgK,EAAK/I,gBAC3C+J,kBAAkBxK,EAAoBR,IAEtCgK,EAAKtG,MAAMoD,UAYToE,wBACAoB,QAAwBtM,GACxBgK,EAAKoG,cAAcpO,EAAQhC,SAdT,GAClBkL,wBACAsB,QAA2BxK,EAAQhC,EAAOgK,EAAKtG,MAAM1B,QACrDsK,QAAwBtM,GAAO,SAG9BiX,EAAoBjN,EAAKqB,YAAYrJ,GACrCsU,EAAW/Z,EAAqB0a,EAAkBza,SAEnD0O,mBAAmB+L,KACnB/L,mBAAmBoL,KAQrBxE,+BAGC,aACDxH,QACAN,EAAKtG,MAAMoD,YACXoE,wBAAwBlB,EAAKqB,YAAYrB,EAAKtG,MAAM1B,SAAS8E,SAAS,EAAO7J,WAAY,CAAC,EAAG,GAAID,SAAU,OAC3G8U,mDAGP3E,YAAA,SAAYF,GACVE,GAAYF,EAAU,WAAYxO,KAAK8X,iBA3CLtG,ICwBhCiH,GAAgB,0CAiEtB,SAASC,GAAwBlL,EAAiCmL,OAC1DC,EAAYD,EAAa,QACzBE,EAAUF,EAAa,aAElB,SAAC1T,OACN4E,OAAYzJ,SACZ6E,EAAMoE,OAASuP,KAAYpL,GAAUA,EAASoL,GAAW3T,GACzD0T,KAAcnL,IAAU3D,EAAO2D,EAASmL,GAAa1T,IACrDA,EAAMqE,MAAQuP,KAAUrL,GAAUA,EAASqL,GAAS5T,GACjD4E,4FCzFqCyC,EAA6BxL,YAAAA,IAAAA,EAA6B,IACxGkK,EAAe8N,IAAI,OAAQhH,QACrBiH,EAAkBC,kBACnBD,EAAgBpI,UACnBoI,EAAgBpI,QAAUsI,GAAQtR,EAAkBgN,KAE/C7D,GAA8B,CAAElJ,KAAM0E,GAAWyM,EAAgBpI,QAAQ7P,iCDsChFoY,EACApY,YAAAA,IAAAA,EAA2B,UA5B7B,SAAsB0M,OACd2L,EAAc,GACdC,EAAc,GACdC,EAAU,IAAIjL,QAEf,IAAInN,KAAOuM,EACViL,GAAca,KAAKrY,IACrBoY,EAAQ5J,IAAIiG,OAAO6D,WACnBH,EAAOnY,GAAQuM,EAAiBvM,IAEhCkY,EAAOlY,GAAQuM,EAAiBvM,SAI7B,CAACmY,EAAQD,EAAQE,GAgBoBG,CAAaN,GAAlD1L,OAAUuD,OAAgBsI,OAEjCrO,EAAe8N,IAAI,OAAQhH,IAC3B9G,EAAe8N,IAAI,QAASf,IAC5B/M,EAAe8N,IAAI,OAAQf,IAC3B/M,EAAe8N,IAAI,QAAStC,IAC5BxL,EAAe8N,IAAI,SAAUP,IAC7BvN,EAAe8N,IAAI,QAASnB,QAEtB8B,WdhB2B3Y,EAA+BuY,YAA/BvY,IAAAA,EAA2B,aAAIuY,IAAAA,EAAuB,IAAIjL,SACnFxG,EAAiG9G,EAAjG8G,KAAMM,EAA2FpH,EAA3FoH,MAAOV,EAAoF1G,EAApF0G,KAAMQ,EAA8ElH,EAA9EkH,OAAQF,EAAsEhH,EAAtEgH,MAAOJ,EAA+D5G,EAA/D4G,MAEpC+R,EAA+BxS,EAA0B,CAC7DvB,UAHuG5E,EAAvB4E,UAIhFC,aAJuG7E,EAAxD6E,aAK/CnD,UALuG1B,EAAlC0B,UAMrEnB,OANuGP,EAA1CO,OAO7DqD,QAPuG5D,EAAZ4D,iBAUzF2U,EAAQ5D,IAAI,YAAWgE,EAAa7R,KAAOR,EAAuBQ,IAClEyR,EAAQ5D,IAAI,aAAYgE,EAAavR,MAAQhB,EAA8BgB,IAC3EmR,EAAQ5D,IAAI,cAAagE,EAAazR,OAASd,EAA8Bc,IAC7EqR,EAAQ5D,IAAI,YAAWgE,EAAajS,KAAON,EAA8BM,IACzE6R,EAAQ5D,IAAI,aAAYgE,EAAa3R,MAAQX,EAAgCW,IAC7EuR,EAAQ5D,IAAI,aAAYgE,EAAa/R,SAAUhD,SAAS,GAASgD,IAE9D+R,EcF8BC,CAAmB5Y,EAAQuY,GAC1DrI,EAA8C,UAEhDqI,EAAQ5D,IAAI,YAAWzE,EAAiBpJ,KAAO8Q,GAAwBlL,EAAU,WACjF6L,EAAQ5D,IAAI,aAAYzE,EAAiB9I,MAAQwQ,GAAwBlL,EAAU,YACnF6L,EAAQ5D,IAAI,cAAazE,EAAiBhJ,OAAS0Q,GAAwBlL,EAAU,aACrF6L,EAAQ5D,IAAI,YAAWzE,EAAiBxJ,KAAOkR,GAAwBlL,EAAU,WACjF6L,EAAQ5D,IAAI,aAAYzE,EAAiBlJ,MAAQ4Q,GAAwBlL,EAAU,YACnF6L,EAAQ5D,IAAI,aAAYzE,EAAiBtJ,MAAQ8F,EAASmM,SAEvD7I,GAAiCE,EAAkByI,EAAc1I,8BElExBzE,EAA8BxL,YAAAA,IAAAA,EAA8B,IAC5GkK,EAAe8N,IAAI,QAASf,QACtB6B,EAAmBZ,kBACpBY,EAAiBjJ,UACpBiJ,EAAiBjJ,QAAUsI,GAAQxR,EAAmBkN,KAEjD7D,GAA+B,CAAEpJ,MAAO4E,GAAWsN,EAAiBjJ,QAAQ7P,8BCNrCwL,EAA6BxL,YAAAA,IAAAA,EAA6B,IACxGkK,EAAe8N,IAAI,OAAQf,QACrB8B,EAAkBb,kBACnBa,EAAgBlJ,UACnBkJ,EAAgBlJ,QAAUsI,GAAQ5R,EAAkBsN,KAE/C7D,GAA8B,CAAEtJ,KAAM8E,GAAWuN,EAAgBlJ,QAAQ7P,+BCNhCwL,EAA8BxL,YAAAA,IAAAA,EAA8B,IAC5GkK,EAAe8N,IAAI,QAAStC,QACtBsD,EAAmBd,kBACpBc,EAAiBnJ,UACpBmJ,EAAiBnJ,QAAUsI,GAAQpR,EAAmB8M,KAEjD7D,GAA+B,CAAEhJ,MAAOwE,GAAWwN,EAAiBnJ,QAAQ7P,gCCNjCwL,EAA+BxL,YAAAA,IAAAA,EAA+B,IAChHkK,EAAe8N,IAAI,SAAUP,QACvBwB,EAAoBf,kBACrBe,EAAkBpJ,UACrBoJ,EAAkBpJ,QAAUsI,GAAQlR,EAAoB4M,KAEnD7D,GAAgC,CAAE9I,OAAQsE,GAAWyN,EAAkBpJ,QAAQ7P,+BCNtCwL,EAA8BxL,YAAAA,IAAAA,EAA8B,IAC5GkK,EAAe8N,IAAI,QAASnB,QACtBqC,EAAmBhB,kBACpBgB,EAAiBrJ,UACpBqJ,EAAiBrJ,QAAUsI,GAAQhR,EAAmB0M,KAEjD7D,GAA+B,CAAE5I,MAAOoE,GAAW0N,EAAiBrJ,QAAQ7P"}